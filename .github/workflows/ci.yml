name: CI

on:
  push:
    branches: [main]
  pull_request:
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ github.ref != 'refs/heads/main' }}  # Cancel only for PRs, not main

permissions:
  contents: write
  packages: write
  pull-requests: write
  issues: write

jobs:
  # Unit tests job - runs first
  test:
    name: Unit Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'
          cache: true

      - name: Setup Bazel
        uses: bazel-contrib/setup-bazel@0.15.0
        with:
          # Avoid downloading Bazel every time
          bazelisk-cache: true
          # Store build cache per workflow
          disk-cache: ${{ github.workflow }}
          # Share repository cache between workflows
          repository-cache: true

      - name: Download dependencies
        run: |
          go mod download
          go mod verify

      - name: Run unit tests with coverage
        run: |
          # Run tests with coverage for SonarCloud (exclude e2e tests)
          echo "Running Go tests with coverage..."
          go test -v -race -coverprofile=coverage.out -covermode=atomic $(go list ./src/... | grep -v /e2e)
          
          echo "Coverage report generated successfully"

      - name: Upload coverage to artifact
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: coverage.out
          retention-days: 7

      - name: Run Bazel tests
        run: |
          echo "Running Bazel tests..."
          bazel test //src/internal/... //src/cmd/... \
            --test_output=errors \
            --cache_test_results=no

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: bazel-testlogs/**/*.xml
          retention-days: 7
        continue-on-error: true


  # Analyze job - runs after test
  analyze:
    name: Code Analysis
    runs-on: ubuntu-latest
    needs: test
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'
          cache: true
          cache-dependency-path: |
            go.sum
            go.mod

      - name: Run golangci-lint
        uses: golangci/golangci-lint-action@v7
        with:
          version: v2.3.1
          args: --timeout=5m ./src/...
          skip-cache: true

  # SonarCloud job - runs after test in parallel with analyze
  sonarcloud:
    name: SonarCloud Analysis
    runs-on: ubuntu-latest
    needs: test
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download coverage report
        uses: actions/download-artifact@v4
        with:
          name: coverage-report
          path: .

      - name: SonarCloud Scan
        uses: SonarSource/sonarqube-scan-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: https://sonarcloud.io

  # Build job - waits for analyze and sonarcloud to complete and handles versioning
  build:
    name: Build Binaries
    runs-on: ubuntu-latest
    needs: [analyze, sonarcloud]
    outputs:
      version: ${{ steps.semver.outputs.next }}
      current: ${{ steps.semver.outputs.current }}
      changelog: ${{ steps.changelog.outputs.changelog }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: What is next version?
        id: semver
        uses: ietf-tools/semver-action@v1
        with:
          token: ${{ github.token }}
          branch: main
          skipInvalidTags: true
          noVersionBumpBehavior: patch
          noNewCommitBehavior: current
          fallbackTag: v0.0.0
          patchList: "vendor, update, fix, bugfix, perf, refactor, test, tests, chore, ci, docs, improve, style, build, revert, improvement, enhancement, coverage, clean"
      
      - name: Generate Changelog
        id: changelog
        uses: TriPSs/conventional-changelog-action@v5
        if: github.event_name != 'pull_request'
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          preset: conventionalcommits
          output-file: false
          skip-version-file: true
          skip-commit: true
          skip-tag: true
          git-push: false
          skip-bump: true

      - name: Setup Bazel
        uses: bazel-contrib/setup-bazel@0.15.0
        with:
          # Avoid downloading Bazel every time
          bazelisk-cache: true
          # Store build cache per workflow
          disk-cache: ${{ github.workflow }}
          # Share repository cache between workflows
          repository-cache: true

      - name: Build all binaries with Bazel
        run: |
          mkdir -p .dist
          
          # Use the version from semver step
          VERSION="${{ steps.semver.outputs.next }}"
          echo "Building with version: ${VERSION}"
          
          # Build for multiple platforms
          for platform in linux/amd64 linux/arm64 darwin/amd64 darwin/arm64 windows/amd64; do
            OS=$(echo $platform | cut -d/ -f1)
            ARCH=$(echo $platform | cut -d/ -f2)
            echo "Building for $OS/$ARCH..."
            
            bazel build --config=ci \
              --platforms=@io_bazel_rules_go//go/toolchain:${OS}_${ARCH} \
              //src/cmd/cloud-update:cloud-update \
              --workspace_status_command="echo BUILD_VERSION ${VERSION}"
            
            # Copy the binary with the appropriate extension
            OUTPUT_NAME="cloud-update-${OS}-${ARCH}"
            if [ "$OS" = "windows" ]; then
              if cp bazel-bin/src/cmd/cloud-update/cloud-update_/cloud-update.exe .dist/${OUTPUT_NAME}.exe 2>/dev/null || \
                 cp bazel-bin/src/cmd/cloud-update/windows_amd64_pure_stripped/cloud-update.exe .dist/${OUTPUT_NAME}.exe 2>/dev/null; then
                echo "‚úì Built ${OUTPUT_NAME}.exe"
              else
                echo "‚úó Failed to build Windows binary for ${ARCH}"
                exit 1
              fi
            else
              if cp bazel-bin/src/cmd/cloud-update/cloud-update_/cloud-update .dist/${OUTPUT_NAME} 2>/dev/null || \
                 cp bazel-bin/src/cmd/cloud-update/${OS}_${ARCH}_pure_stripped/cloud-update .dist/${OUTPUT_NAME} 2>/dev/null; then
                chmod +x .dist/${OUTPUT_NAME}
                echo "‚úì Built ${OUTPUT_NAME}"
              else
                echo "‚úó Failed to build ${OS}/${ARCH} binary"
                exit 1
              fi
            fi
          done
          
          # List generated binaries
          echo "Generated binaries:"
          ls -la .dist/

      - name: Upload binaries
        uses: actions/upload-artifact@v4
        with:
          name: cloud-update-binaries
          path: .dist/
          if-no-files-found: error
          include-hidden-files: true

  # E2E tests - runs for both PR and main
  e2e:
    name: E2E Tests
    runs-on: ubuntu-latest
    needs: build
    strategy:
      fail-fast: false
      matrix:
        init_system:
          - { name: openrc, distro: alpine }
          - { name: systemd, distro: ubuntu }
          - { name: sysvinit, distro: debian }
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download binaries
        uses: actions/download-artifact@v4
        with:
          name: cloud-update-binaries
          path: .dist/

      - name: Prepare binary for container
        run: |
          # The E2E test script expects the binary in a specific location
          mkdir -p dist/cloud-update_linux_amd64_v1
          cp .dist/cloud-update-linux-amd64 dist/cloud-update_linux_amd64_v1/cloud-update
          chmod +x dist/cloud-update_linux_amd64_v1/cloud-update

          # Also copy to the location expected by Dockerfile
          mkdir -p src/test/e2e
          cp .dist/cloud-update-linux-amd64 src/test/e2e/cloud-update
          chmod +x src/test/e2e/cloud-update

      - name: Run E2E test for ${{ matrix.init_system.name }}
        run: |
          # Export required environment variables
          export E2E_SECRET="test-secret-key-for-e2e-testing-purposes-only"
          export CLOUD_UPDATE_SECRET="test-secret-key-for-e2e-testing-purposes-only"
          export CLOUD_UPDATE_LOG_LEVEL="debug"

          chmod +x src/test/e2e/test_distro.sh
          ./src/test/e2e/test_distro.sh ${{ matrix.init_system.distro }}

      - name: Clean up containers
        if: always()
        run: docker compose -f src/test/e2e/docker-compose.yml down --volumes --remove-orphans || true

  # Release job - creates prerelease for PR or final release for main
  release:
    name: Create Release
    needs: [build, e2e]
    runs-on: ubuntu-latest
    # Prevent concurrent releases on main branch to avoid version conflicts
    # Only apply concurrency control on main branch
    concurrency:
      group: release-${{ github.ref }}
      cancel-in-progress: false  # Wait for previous release to complete instead of canceling
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download binaries
        uses: actions/download-artifact@v4
        with:
          name: cloud-update-binaries
          path: .dist/

      - name: Create archives
        run: |
          cd .dist
          
          # Create archives
          for file in cloud-update-*; do
            if [[ "$file" == *.exe ]]; then
              # For Windows, create a zip file
              zip "${file%.exe}.zip" "$file"
              echo "Created ${file%.exe}.zip"
            else
              # For Unix systems, create tar.gz
              tar -czf "${file}.tar.gz" "$file"
              echo "Created ${file}.tar.gz"
            fi
          done
          
          # Generate SHA256 checksums
          echo "Generating SHA256 checksums..."
          sha256sum *.tar.gz *.zip 2>/dev/null > checksums.sha256 || true
          
          # Display checksums for verification
          echo "SHA256 Checksums:"
          cat checksums.sha256
          
          cd ..
          
          # List archives
          echo "Release archives:"
          ls -la .dist/*.{tar.gz,zip} 2>/dev/null || true

      - name: Generate Release Notes
        id: release_notes
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            # PR - Create prerelease notes
            cat << EOF > release_notes.md
          ## üî¨ Prerelease for PR #${{ github.event.pull_request.number }}
          
          This is a prerelease build for testing purposes.
          
          ### üìã Pull Request Information
          - **Title:** ${{ github.event.pull_request.title }}
          - **Branch:** \`${{ github.head_ref }}\` ‚Üí \`${{ github.base_ref }}\`
          - **Commit:** [\`${GITHUB_SHA:0:7}\`](https://github.com/${{ github.repository }}/commit/${{ github.sha }})
          - **Author:** @${{ github.event.pull_request.user.login }}
          
          ### ‚úÖ Test Status
          | Test Suite | Status |
          |------------|--------|
          | Unit Tests | ‚úÖ Passed |
          | Code Analysis | ‚úÖ Passed |
          | SonarCloud | ‚úÖ Passed |
          | Build | ‚úÖ Completed |
          | E2E Tests | ‚úÖ Passed |
          
          ### üì¶ Available Downloads
          Platform-specific binaries with SHA256 checksums are attached below.
          
          > ‚ö†Ô∏è **Note**: This is a prerelease and should not be used in production.
          EOF
          else
            # Main branch - Create final release notes
            CURRENT_TAG="${{ needs.build.outputs.version }}"
            PREVIOUS_TAG="${{ needs.build.outputs.current }}"
            
            # Get release date
            RELEASE_DATE=$(date -u +"%Y-%m-%d")
            
            # Use the changelog from the build job if available
            CHANGELOG_BODY='${{ needs.build.outputs.changelog }}'
            
            if [ -z "$CHANGELOG_BODY" ] || [ "$CHANGELOG_BODY" == "null" ]; then
              # Fallback to manual generation if changelog action wasn't run
              # Get statistics
              if [ -z "$PREVIOUS_TAG" ] || [ "$PREVIOUS_TAG" == "null" ] || [ "$PREVIOUS_TAG" == "v0.0.0" ]; then
                COMMIT_COUNT="Initial"
                FILE_CHANGES="N/A"
                CONTRIBUTORS="@${{ github.actor }}"
                CHANGELOG_CONTENT="## Initial Release\n\n- Initial release of Cloud Update service"
              else
                COMMIT_COUNT=$(git rev-list --count ${PREVIOUS_TAG}..HEAD)
                FILE_CHANGES=$(git diff --shortstat ${PREVIOUS_TAG}..HEAD | tail -1)
                CONTRIBUTORS=$(git log --pretty=format:"@%an" ${PREVIOUS_TAG}..HEAD | sort -u | tr '\n' ', ' | sed 's/,$//' | sed 's/,/, /g')
                
                # Simple changelog generation
                CHANGELOG_CONTENT="## Changes\n\n"
                while IFS= read -r line; do
                  HASH=$(echo "$line" | cut -d'|' -f1)
                  MSG=$(echo "$line" | cut -d'|' -f2)
                  if [[ "$MSG" != Merge* ]]; then
                    CHANGELOG_CONTENT="${CHANGELOG_CONTENT}- ${MSG} [\`${HASH:0:7}\`](https://github.com/${{ github.repository }}/commit/${HASH})\n"
                  fi
                done < <(git log --pretty=format:"%H|%s" ${PREVIOUS_TAG}..HEAD --no-merges | head -20)
              fi
            else
              # Use the generated changelog
              CHANGELOG_CONTENT="$CHANGELOG_BODY"
              # Get statistics
              if [ -z "$PREVIOUS_TAG" ] || [ "$PREVIOUS_TAG" == "null" ] || [ "$PREVIOUS_TAG" == "v0.0.0" ]; then
                COMMIT_COUNT="Initial"
                FILE_CHANGES="N/A"
                CONTRIBUTORS="@${{ github.actor }}"
              else
                COMMIT_COUNT=$(git rev-list --count ${PREVIOUS_TAG}..HEAD)
                FILE_CHANGES=$(git diff --shortstat ${PREVIOUS_TAG}..HEAD | tail -1)
                CONTRIBUTORS=$(git log --pretty=format:"@%an" ${PREVIOUS_TAG}..HEAD | sort -u | tr '\n' ', ' | sed 's/,$//' | sed 's/,/, /g')
              fi
            fi
            
            # Format release notes
            cat << EOF > release_notes.md
          # Release ${CURRENT_TAG}
          
          üìÖ **Release Date:** ${RELEASE_DATE}
          
          ${CHANGELOG_CONTENT}
          
          ## üìä Release Statistics
          
          - **Commits:** ${COMMIT_COUNT}
          - **Changed Files:** ${FILE_CHANGES}
          - **Contributors:** ${CONTRIBUTORS}
          
          ## üì¶ Downloads
          
          | Platform | Architecture | Download |
          |----------|-------------|----------|
          | Linux | x86_64 | \`cloud-update-linux-amd64.tar.gz\` |
          | Linux | ARM64 | \`cloud-update-linux-arm64.tar.gz\` |
          | macOS | x86_64 | \`cloud-update-darwin-amd64.tar.gz\` |
          | macOS | Apple Silicon | \`cloud-update-darwin-arm64.tar.gz\` |
          | Windows | x86_64 | \`cloud-update-windows-amd64.zip\` |
          
          ### üîê Verification
          
          All binaries come with SHA256 checksums in \`checksums.sha256\`.
          
          To verify a download:
          \`\`\`bash
          sha256sum -c checksums.sha256
          \`\`\`
          
          ## üîó Links
          
          - [Full Changelog](https://github.com/${{ github.repository }}/compare/${PREVIOUS_TAG:-v0.0.0}...${CURRENT_TAG})
          - [Documentation](https://github.com/${{ github.repository }}#readme)
          - [Issues](https://github.com/${{ github.repository }}/issues)
          
          ---
          
          <sub>Generated by Cloud Update CI/CD Pipeline</sub>
          EOF
          fi

      - name: Create or Update Release
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            # PR - Create/update prerelease
            RELEASE_TAG="${{ needs.build.outputs.version }}-pr${{ github.event.pull_request.number }}"
            
            # Check if release already exists
            if gh release view "${RELEASE_TAG}" &>/dev/null; then
              echo "üìù Updating existing prerelease: ${RELEASE_TAG}"
              
              # Delete old assets
              gh release delete-asset "${RELEASE_TAG}" --pattern "*" -y 2>/dev/null || true
              
              # Update the release
              gh release edit "${RELEASE_TAG}" \
                --title "Prerelease ${RELEASE_TAG}" \
                --notes-file release_notes.md \
                --draft \
                --prerelease
              
              # Upload new assets
              gh release upload "${RELEASE_TAG}" \
                .dist/*.tar.gz \
                .dist/*.zip \
                .dist/checksums.sha256 \
                --clobber
            else
              echo "üÜï Creating new prerelease: ${RELEASE_TAG}"
              
              # Create new prerelease
              gh release create "${RELEASE_TAG}" \
                --title "Prerelease ${RELEASE_TAG}" \
                --notes-file release_notes.md \
                --draft \
                --prerelease \
                .dist/*.tar.gz \
                .dist/*.zip \
                .dist/checksums.sha256
            fi
          else
            # Main branch - Create final release
            VERSION="${{ needs.build.outputs.version }}"
            CURRENT="${{ needs.build.outputs.current }}"
            
            echo "Current version: $CURRENT"
            echo "Next version: $VERSION"
            
            # CRITICAL: Fetch latest tags to ensure we have the most recent versions
            # This is essential for concurrent merges
            echo "Fetching latest tags..."
            git fetch --tags --force
            
            # Get the actual latest tag from git (not from GitHub releases)
            LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            echo "Latest tag from git: $LATEST_TAG"
            
            # Also check latest release to be sure
            LATEST_RELEASE=$(gh release list --limit 1 --exclude-drafts --exclude-pre-releases | grep -E "^Release" | awk '{print $4}' || echo "v0.0.0")
            echo "Latest release in GitHub: $LATEST_RELEASE"
            
            # Use the highest version between tag and release
            ACTUAL_LATEST="$LATEST_TAG"
            if [ "$LATEST_RELEASE" != "v0.0.0" ]; then
              # Compare versions and use the highest
              LATEST_TAG_NUM=$(echo "$LATEST_TAG" | tr -d 'v' | tr '.' ' ')
              LATEST_REL_NUM=$(echo "$LATEST_RELEASE" | tr -d 'v' | tr '.' ' ')
              if [ "$(echo "$LATEST_REL_NUM" | awk '{print $1*10000 + $2*100 + $3}')" -gt "$(echo "$LATEST_TAG_NUM" | awk '{print $1*10000 + $2*100 + $3}')" ]; then
                ACTUAL_LATEST="$LATEST_RELEASE"
              fi
            fi
            echo "Using as base version: $ACTUAL_LATEST"
            
            # If the actual latest is newer than what semver calculated, recalculate
            if [ "$ACTUAL_LATEST" != "$CURRENT" ] && [ "$ACTUAL_LATEST" != "v0.0.0" ]; then
              echo "Warning: Actual latest ($ACTUAL_LATEST) differs from semver current ($CURRENT)"
              echo "Recalculating version based on actual latest..."
              CURRENT="$ACTUAL_LATEST"
              
              # Determine version bump based on commit message
              COMMIT_MSG=$(git log -1 --pretty=%B)
              if echo "$COMMIT_MSG" | grep -qE "^(feat|feature):"; then
                # Minor version bump
                VERSION=$(echo "$ACTUAL_LATEST" | awk -F. '{gsub("v","",$1); print "v"$1"."$2+1".0"}')
              elif echo "$COMMIT_MSG" | grep -qE "BREAKING CHANGE|^[^:]+!:"; then
                # Major version bump
                VERSION=$(echo "$ACTUAL_LATEST" | awk -F. '{gsub("v","",$1); print "v"$1+1".0.0"}')
              else
                # Patch version bump (default)
                VERSION=$(echo "$ACTUAL_LATEST" | awk -F. '{gsub("v","",$1); print "v"$1"."$2"."$3+1}')
              fi
              echo "Recalculated version: $VERSION"
            fi
            
            # Check if we need a new release
            if [ "$VERSION" != "$CURRENT" ] || [ "$CURRENT" == "v0.0.0" ]; then
              # Clean up prereleases from all merged PRs
              echo "Cleaning up prereleases from merged PRs..."
              
              # Get list of all merged PR numbers
              MERGED_PRS=$(gh pr list --state merged --limit 100 --json number -q '.[].number')
              
              # Get all prerelease tags and check if their PR is merged
              for tag in $(gh release list --limit 100 | grep -E "pr[0-9]+" | awk '{print $(NF-1)}' | grep -E "v[0-9]+\.[0-9]+\.[0-9]+\-pr[0-9]+"); do
                # Extract PR number from tag
                pr_num=$(echo "$tag" | grep -oE "pr[0-9]+" | tr -d 'pr')
                
                # Check if this PR is merged
                if echo "$MERGED_PRS" | grep -q "^${pr_num}$"; then
                  echo "Deleting prerelease $tag (PR #$pr_num is merged)"
                  gh release delete "$tag" -y || true
                  git push --delete origin "$tag" 2>/dev/null || true
                else
                  echo "Keeping prerelease $tag (PR #$pr_num is still open)"
                fi
              done
              
              # Create tag if needed
              if ! git rev-parse "$VERSION" >/dev/null 2>&1; then
                echo "Creating new tag: $VERSION"
                git config user.name "github-actions"
                git config user.email "github-actions@github.com"
                git tag -a "$VERSION" -m "Release $VERSION"
                git push origin "$VERSION"
              fi
              
              # Final check before creating release to avoid race conditions
              # Re-check if the release was created by another concurrent job
              if gh release view "$VERSION" &>/dev/null; then
                echo "‚ö†Ô∏è Release $VERSION already exists (likely created by concurrent job)"
                echo "üìù Updating existing release with our artifacts..."
                # Delete old assets
                gh release delete-asset "$VERSION" --pattern "*" -y 2>/dev/null || true
                # Update release
                gh release edit "$VERSION" \
                  --title "Release $VERSION" \
                  --notes-file release_notes.md \
                  --latest
                # Upload new assets
                gh release upload "$VERSION" \
                  .dist/*.tar.gz \
                  .dist/*.zip \
                  .dist/checksums.sha256 \
                  --clobber
              else
                echo "üöÄ Creating new release: $VERSION"
                # Use --verify-tag=false to handle case where tag exists but release doesn't
                gh release create "$VERSION" \
                  --title "Release $VERSION" \
                  --notes-file release_notes.md \
                  --latest \
                  --verify-tag=false \
                  .dist/*.tar.gz \
                  .dist/*.zip \
                  .dist/checksums.sha256 || {
                  # If creation fails (e.g., race condition), try updating instead
                  echo "‚ö†Ô∏è Release creation failed, attempting update..."
                  gh release edit "$VERSION" \
                    --title "Release $VERSION" \
                    --notes-file release_notes.md \
                    --latest
                  gh release upload "$VERSION" \
                    .dist/*.tar.gz \
                    .dist/*.zip \
                    .dist/checksums.sha256 \
                    --clobber
                }
              fi
            else
              echo "No new version to release"
            fi
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}